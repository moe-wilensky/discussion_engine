"""
Invite system service for platform and discussion invites.

Manages invite creation, consumption, earning, and tracking.
"""

import random
import string
from typing import Optional, Tuple
from datetime import timezone as dt_timezone
from decimal import Decimal

from django.core.exceptions import ValidationError
from django.db import transaction
from django.utils import timezone

from core.models import User, Discussion, Invite, PlatformConfig, DiscussionParticipant


class InviteService:
    """
    Core invite business logic for platform and discussion invites.
    """

    INVITE_CODE_LENGTH = 8

    @staticmethod
    def can_send_invite(user: User, invite_type: str) -> Tuple[bool, str]:
        """
        Check if user has invites available.

        Args:
            user: User attempting to send invite
            invite_type: 'platform' or 'discussion'

        Returns:
            Tuple of (can_send, reason_if_not)
        """
        config = PlatformConfig.load()

        # No responses threshold check needed - users get invites immediately on joining
        
        # Check banked invites (must have at least 1.0 to send)
        if invite_type == "platform":
            if user.platform_invites_banked < 1:
                return False, "No platform invites available"
        elif invite_type == "discussion":
            if user.discussion_invites_banked < 1:
                return False, "No discussion invites available"
        else:
            return False, "Invalid invite type"

        return True, ""

    @staticmethod
    def send_platform_invite(inviter: User) -> Tuple[Invite, str]:
        """
        Generate unique invite code for platform.

        Args:
            inviter: User sending the invite

        Returns:
            Tuple of (Invite object, invite_code string)

        Raises:
            ValidationError: If user cannot send invites
        """
        can_send, reason = InviteService.can_send_invite(inviter, "platform")
        if not can_send:
            raise ValidationError(reason)

        config = PlatformConfig.load()

        with transaction.atomic():
            # Create invite (code auto-generated by model)
            invite = Invite.objects.create(
                inviter=inviter, invite_type="platform", status="sent"
            )

            # Consume invite based on config
            if config.invite_consumption_trigger == "sent":
                inviter.consume_invite("platform")
                inviter.save()

        return invite, invite.code

    @staticmethod
    def send_discussion_invite(
        inviter: User, discussion: Discussion, invitee: User
    ) -> Invite:
        """
        Invite user to specific discussion.

        Args:
            inviter: User sending the invite
            discussion: Discussion to invite to
            invitee: User being invited

        Returns:
            Created Invite object

        Raises:
            ValidationError: If invite cannot be sent
        """
        # Validate inviter is active participant (includes initiators)
        if not DiscussionParticipant.objects.filter(
            discussion=discussion, user=inviter, role__in=["initiator", "active"]
        ).exists():
            raise ValidationError("Only active participants can send invites")

        # Check if discussion is at cap
        config = PlatformConfig.load()
        current_participants = DiscussionParticipant.objects.filter(
            discussion=discussion, role__in=["initiator", "active"]
        ).count()

        if current_participants >= config.max_discussion_participants:
            raise ValidationError("Discussion is at maximum capacity")

        # Check if invitee already participant
        if DiscussionParticipant.objects.filter(
            discussion=discussion, user=invitee
        ).exists():
            raise ValidationError("User is already a participant")

        # Check if pending invite exists
        if Invite.objects.filter(
            inviter=inviter,
            invitee=invitee,
            discussion=discussion,
            status="sent",
            invite_type="discussion",
        ).exists():
            raise ValidationError("Invite already pending for this user")

        can_send, reason = InviteService.can_send_invite(inviter, "discussion")
        if not can_send:
            raise ValidationError(reason)

        with transaction.atomic():
            # Create invite
            invite = Invite.objects.create(
                inviter=inviter,
                invitee=invitee,
                invite_type="discussion",
                discussion=discussion,
                status="sent",
            )

            # Consume invite if configured
            config = PlatformConfig.load()
            if config.invite_consumption_trigger == "sent":
                inviter.consume_invite("discussion")

            # Send notification via Celery
            from core.tasks import send_invite_notification

            send_invite_notification.delay(str(invite.id))

        return invite

    @staticmethod
    def accept_invite(invite: Invite, user: Optional[User] = None) -> User:
        """
        Accept an invite.

        Args:
            invite: Invite object to accept
            user: User accepting (for platform invites, this may be None initially)

        Returns:
            User that accepted the invite

        Raises:
            ValidationError: If invite cannot be accepted
        """
        if invite.status != "sent":
            raise ValidationError("Invite has already been processed")

        config = PlatformConfig.load()

        with transaction.atomic():
            # For discussion invites
            if invite.invite_type == "discussion":
                if not user or user.id != invite.invitee.id:
                    raise ValidationError("Invalid user for this invite")

                # Add user to discussion participants
                DiscussionParticipant.objects.create(
                    discussion=invite.discussion, user=user, role="active"
                )

                # Update invite
                invite.status = "accepted"
                invite.accepted_at = timezone.now()
                invite.save()

                # Consume invite if configured
                if config.invite_consumption_trigger == "accepted":
                    invite.inviter.consume_invite("discussion")

            # For platform invites
            elif invite.invite_type == "platform":
                if not user:
                    raise ValidationError("User required for platform invite")

                # Set invitee
                invite.invitee = user
                invite.status = "accepted"
                invite.accepted_at = timezone.now()
                invite.save()

                # Grant starting invites to new user
                user.platform_invites_acquired = config.new_user_platform_invites
                user.platform_invites_banked = config.new_user_platform_invites
                user.discussion_invites_acquired = config.new_user_discussion_invites
                user.discussion_invites_banked = config.new_user_discussion_invites
                user.save()

                # Consume invite if configured
                if config.invite_consumption_trigger == "accepted":
                    invite.inviter.consume_invite("platform")

        return user

    @staticmethod
    def decline_invite(invite: Invite, user: User) -> None:
        """
        Decline an invite.

        Args:
            invite: Invite to decline
            user: User declining the invite

        Raises:
            ValidationError: If invite cannot be declined
        """
        if invite.status != "sent":
            raise ValidationError("Invite has already been processed")

        if invite.invitee and invite.invitee.id != user.id:
            raise ValidationError("Invalid user for this invite")

        invite.status = "declined"
        invite.save()

    @staticmethod
    def track_first_participation(user: User, discussion: Discussion) -> None:
        """
        Track when invited user first participates in discussion.

        Args:
            user: User who participated
            discussion: Discussion they participated in
        """
        # Find discussion invite for this user/discussion
        invite = Invite.objects.filter(
            invitee=user,
            discussion=discussion,
            invite_type="discussion",
            status="accepted",
            first_participation_at__isnull=True,
        ).first()

        if invite:
            invite.first_participation_at = timezone.now()
            invite.save()

            # Consume invite if not already consumed
            config = PlatformConfig.load()
            if config.invite_consumption_trigger not in ["sent", "accepted"]:
                invite.inviter.consume_invite("discussion")

    @staticmethod
    def earn_invite_from_response(user: User, skip_credits: bool = False) -> dict:
        """
        Called after each response submission to award invites.
        
        Awards 0.2 platform invites and 1.0 discussion invite per response.

        Args:
            user: User who submitted response
            skip_credits: If True, don't award invites (for returning from observer)

        Returns:
            Dict with earned invite counts
        """
        if skip_credits:
            return {
                "platform_invites_earned": Decimal('0'),
                "discussion_invites_earned": Decimal('0'),
                "total_platform": user.platform_invites_acquired,
                "total_discussion": user.discussion_invites_acquired,
            }
        
        config = PlatformConfig.load()

        # Award fractional invites per response (ensure Decimal type)
        platform_per_response = Decimal(str(config.platform_invites_per_response))
        discussion_per_response = Decimal(str(config.discussion_invites_per_response))

        # Update user's acquired and banked invites
        with transaction.atomic():
            user.refresh_from_db()

            user.platform_invites_acquired += platform_per_response
            user.platform_invites_banked += platform_per_response
            
            user.discussion_invites_acquired += discussion_per_response
            user.discussion_invites_banked += discussion_per_response

            user.save()

        return {
            "platform_invites_earned": platform_per_response,
            "discussion_invites_earned": discussion_per_response,
            "total_platform": user.platform_invites_acquired,
            "total_discussion": user.discussion_invites_acquired,
        }

    @staticmethod
    def earn_invite_from_vote(user: User) -> Tuple[Decimal, int]:
        """
        Award voting credits when user participates in voting.

        Awards: 0.2 platform invite + 1 discussion invite

        Added: 2026-02 for voting-based credit system

        Args:
            user: User who cast any vote during voting phase

        Returns:
            tuple: (platform_credits_added, discussion_credits_added)
        """
        platform_credits = Decimal('0.2')
        discussion_credits = 1

        with transaction.atomic():
            user.refresh_from_db()

            user.platform_invites_acquired += platform_credits
            user.platform_invites_banked += platform_credits

            user.discussion_invites_acquired += discussion_credits
            user.discussion_invites_banked += discussion_credits

            user.save()

        return (platform_credits, discussion_credits)

    @staticmethod
    def _generate_invite_code() -> str:
        """Generate unique 8-character invite code."""
        chars = string.ascii_uppercase + string.digits
        return "".join(random.choices(chars, k=InviteService.INVITE_CODE_LENGTH))

    @staticmethod
    def get_invite_by_code(invite_code: str) -> Optional[Invite]:
        """
        Find invite by its code.

        Args:
            invite_code: 8-character invite code

        Returns:
            Invite object or None
        """
        try:
            return Invite.objects.get(code=invite_code)
        except Invite.DoesNotExist:
            return None

    @staticmethod
    def validate_code(code_string: str) -> Invite:
        """
        Validate invite code and return invite if valid.

        Args:
            code_string: Invite code to validate

        Returns:
            Valid Invite object

        Raises:
            ValidationError: If code is invalid, already used, or expired
        """
        # Find invite by code
        invite = InviteService.get_invite_by_code(code_string)

        if not invite:
            raise ValidationError("Invalid invite code")

        # Check status
        if invite.status != "sent":
            raise ValidationError("Invite code has already been used")

        # Check invite type
        if invite.invite_type != "platform":
            raise ValidationError("Invalid invite type")

        # Check expiration (if set)
        if invite.expires_at:
            if timezone.now() > invite.expires_at:
                # Mark as expired
                invite.status = "expired"
                invite.save()
                raise ValidationError("Invite code has expired")

        return invite

    @staticmethod
    def consume_code(code_string: str, user: User) -> Invite:
        """
        Validate and consume invite code during registration.

        Args:
            code_string: Invite code to consume
            user: User who is consuming the invite

        Returns:
            Accepted Invite object

        Raises:
            ValidationError: If code is invalid or cannot be consumed
        """
        with transaction.atomic():
            # Validate the code
            invite = InviteService.validate_code(code_string)

            # Accept the invite
            InviteService.accept_invite(invite, user)

            return invite
